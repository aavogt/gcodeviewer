/* watch-code-cells segdistance.mac --reload codegen.mac 
   maxima < segdistance.mac # without aavogt/watch-code-cells
 * */
/* 
 if you have line segments p(s) q(s) on s from 0 to 1,

  [a,c,e] = p0 - q0
  [b,d,f] = (p1-p0) - (q1-q0)

  this generates a f1 in src/segdistance.h which computes the area
  in between the line segments.

  but my line segments are 3-dimensional, and 3d integral
  with the naive dy = c+ds; dz = e + fs can't be solved in a few seconds.

  But we can pick a rotation that makes d=f=0, b >= 0. Apply it to [a,c,e] as well?
  and this gives a closed form that's slower and probably slower and less
  accurate than a numerical integration (even a fixed Gauss Konrod rule from
  gsl or quadpack), but that benchmark is for later.
 */ 
load("codegen.mac")$
dx : a + b*s;
dy : c  ;
dz : d ;
assume(notequal(a, 0))$
assume(d^2 + c^2 > 0)$
assume(b > 0)$
integrate(sqrt(dx^2 + dy^2 + dz^2), s, 0, 1)$
r : radcan(%);

/* [a,b,c] = r0 - p0
 * ray: r0 + [1,0,0]s
 * segment: p0 + [d,e,f]*t
 */
xr : a + s - d*t;
yr : b + - e*t;
zr : c + - f*t;
dist : xr^2 + yr^2 + zr^2;
stEq : solve([diff(dist, s), diff(dist, t)], [s,t])[1];

minDist : subst([t=assoc(t, stEq),s = Clamp(assoc(s, stEq), 0, 1)], dist);

with_stdout("../src/segdistance.h",
  (printf(true, "// generated from ../mac/segdistance.mac~%"),
   codegen(r),
   codegen(minDist)
   ))$
